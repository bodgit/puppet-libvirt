require 'tempfile'
require 'rexml/document'
require 'pp'

include REXML

Puppet::Type.type(:libvirt_network).provide(:virsh) do

  commands :virsh => 'virsh'

  mk_resource_methods

  def initialize(value={}, uuid=nil, xml=nil)
    super(value)

    @property_flush = {}

    @uuid = uuid
    @xml  = xml
  end

  def self.instances
    output = virsh '-q', 'net-list', '--all'
    output.split("\n").collect do |l|
      values = l.strip.split(/\s+/)

      xml = virsh '-q', 'net-dumpxml', values[0]
      doc = Document.new(xml, { :ignore_whitespace_nodes => :all })

      network = {
        :name       => values[0],
        :ensure     => :present,
        :active     => values[1] == 'active' ? :true : :false,
        :autostart  => values[2] == 'yes'    ? :true : :false,
        :persistent => values[3] == 'yes'    ? :true : :false,
        :provider   => self.name
      }

      uuid = XPath.first(doc, '/network/uuid').text

      if forward = XPath.first(doc, '/network/forward')
        if forward.attributes.include?('mode')
          network[:forward_mode] = forward.attributes['mode'].to_sym
        end
      end

      if bridge = XPath.first(doc, '/network/bridge')
        network[:bridge] = bridge.attributes['name']
        if bridge.attributes.include?('stp')
          network[:stp] = bridge.attributes['stp'] == 'off' ? :false : :true
        end
        if bridge.attributes.include?('delay')
          network[:delay] = bridge.attributes['delay'].to_i
        end
      end

      # Eurgh!
      output = ''
      doc.write output

      new(network, uuid, output)
    end
  end

  def exists?
    @property_hash[:ensure] == :present
  end

  def self.prefetch(resources)
    instances.each do |provider|
      if resource = resources[provider.name]
        resource.provider = provider
      end
    end
  end

  def destroy
    @property_flush[:ensure] = :absent
  end

  def active=(value)
    @property_flush[:active] = value
  end

  def autostart=(value)
    @property_flush[:autostart] = value
  end

  def persistent=(value)
    @property_flush[:persistent] = value
  end

  def flush

    xml = network_xml(resource)

    case @property_flush[:ensure]
    when :present

      # The resource doesn't exist at all
      begin
        temp = Tempfile.new("libvirt_network.#{resource[:name]}")

        temp.write(xml)
        temp.rewind

        case resource[:persistent]
        when :true
          virsh 'net-define', temp.path

          # Flush the active and autostart properties only if they're true
          @property_flush[:active] = resource[:active] if resource[:active] == :true
          @property_flush[:autostart] = resource[:autostart] if resource[:autostart] == :true
        when :false
          virsh 'net-create', temp.path
        end
      ensure
        temp.close
        temp.unlink
      end
    when :absent

      # Both persistent and transient networks get destroyed
      virsh 'net-destroy', resource[:name]

      # Persistent networks get undefined as well
      if @property_hash[:persistent] == :true
        virsh 'net-undefine', resource[:name]
      end

      return
    end

    # This is a hack; it's just string-comparing the XML read with
    # 'virsh net-dumpxml' against what is generated by this provider. As both
    # XML documents are flattened with no linebreaks or indentation this
    # should work however it would be better being refactored to use some sort
    # of XML-aware comparator
    if @xml and xml != @xml
      begin
        temp = Tempfile.new("libvirt_network.#{resource[:name]}")
        temp.write xml
        temp.rewind
        virsh 'net-define', temp.path
      ensure
        temp.close
        temp.unlink
      end
      virsh 'net-destroy', resource[:name]
      virsh 'net-start', resource[:name]
    end

    case @property_flush[:persistent]
    when :true
      begin
        temp = Tempfile.new("libvirt_network.#{resource[:name]}")
        temp.write virsh '-q', 'net-dumpxml', resource[:name]
        temp.rewind
        virsh 'net-define', temp.path
      ensure
        temp.close
        temp.unlink
      end
    when :false
      # To make a persistent network transient undefine it while it's running
      if @property_hash[:active] == :false
        virsh 'net-start', resource[:name]
      end
      virsh 'net-undefine', resource[:name]
    end

    # Only persistent networks can be inactive
    case @property_flush[:active]
    when :true
      virsh 'net-start', resource[:name]
    when :false
      virsh 'net-destroy', resource[:name]
    end

    # Only persistent networks can be autostarted
    case @property_flush[:autostart]
    when :true
      virsh 'net-autostart', resource[:name]
    when :false
      virsh 'net-autostart', resource[:name], '--disable'
    end
  end

  def create
    @property_flush[:ensure] = :present
  end

  def network_xml(resource)
    doc = Document.new

    network = doc.add_element 'network'

    name = network.add_element 'name'
    name.add_text resource[:name]

    if @uuid
      uuid = network.add_element 'uuid'
      uuid.add_text @uuid
    end

    if resource[:forward_mode]
      forward = network.add_element 'forward'
      forward.add_attribute 'mode', resource[:forward_mode].to_s
    end

    if resource[:bridge]
      bridge = network.add_element 'bridge'
      bridge.add_attribute 'name', resource[:bridge]

      if resource[:forward_mode] and resource[:forward_mode] != :bridge
        bridge.add_attribute 'stp', resource[:stp] == :true ? 'on' : 'off'
        bridge.add_attribute 'delay', resource[:delay]
      end
    end

    # Eurgh!
    output = ''
    doc.write output

    output
  end
end
